{"version":3,"sources":["logger.js"],"names":[],"mappings":"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","file":"logger.js","sourcesContent":["/**\n * Logger module.\n *\n * @module logger\n */\nimport chalk from 'chalk';\nimport moment from 'moment';\nimport { inspect } from 'util';\nimport { defaultLogLevels, OUT_TIME_FMT, IS_COLOURED, genLogLevel } from './constants';\n\n/**\n * @summary Wrap a function based on colour supports.\n *\n * @desc If supports colour, return the function, otherwise return a echo function `whatever => whatever`\n *\n * @param  {Function} fn Function to be filtered.\n * @return {Function}      The filtered function.\n */\nfunction fnFilterByColour( fn ) {\n\n  if ( IS_COLOURED ) {\n    return fn;\n  }\n\n  return whatever => whatever;\n}\n\nconst C = new Map( [\n  [ 'highlight', fnFilterByColour( chalk.cyan ) ],\n  [ 'time', fnFilterByColour( chalk.gray ) ],\n  [ 'info', fnFilterByColour( chalk.reset ) ],\n  [ 'warn', fnFilterByColour( chalk.yellow ) ],\n  [ 'error', fnFilterByColour( chalk.red ) ],\n  [ 'debug', fnFilterByColour( chalk.blue ) ],\n  [ 'help', fnFilterByColour( chalk.green ) ]\n] );\n\nlet _logLevel = new Map( defaultLogLevels );\nlet _timeFormat = OUT_TIME_FMT;\n\n/**\n * Logger class with logging APIs and related helper APIs.\n */\nclass Logger {\n\n  /**\n   * @summary Get the colour mapping of the logger.\n   *\n   * @desc A map of colour case and corresponding colour function from `chalk`, of `{ colourCase: fn }` format.\n   *\n   * For example `{ highlight: ( content ) => hightlightFn( content ) }`.\n   *\n   * @type {Map}\n   */\n  get colorMapping( ) {\n    return C;\n  }\n\n  /**\n   * @summary Set the colour mapping of the logger.\n   *\n   * @desc A map of colour case and corresponding colour function from `chalk`, of `{ colourCase: fn }` format.\n   *\n   * If a colour case doesn't exist, the configuration will be omitted. The currently supported colour cases are:\n   *\n   * - `highlight`\n   * - `time`\n   * - `info`\n   * - `warn`\n   * - `error`\n   * - `debug` - also used in `log` and `verbose` cases.\n   * - `help` - not in use\n   *\n   * @type {Map}\n   * @param {Map} configs A map of colour case and corresponding colour function from `chalk`, of `{ colourCase: fn }` format.\n   */\n  set colorMapping( configs ) {\n\n    for ( const [ key, val ] of configs ) {\n\n      // only update what exists\n      if ( C.has( key ) ) {\n        C.set( key, fnFilterByColour( val ) );\n      }\n    }\n\n  }\n\n  /**\n   * @summary Get the log level configurations of the logger.\n   *\n   * @desc A map of log level is provided, of `{ logLevel: Boolean }` format.\n   *\n   * For example `map.get('INFO')` will be `true`, if the `INFO=true` is given when start the application.\n   *\n   * @type {Map}\n   */\n  get logLevel( ) {\n    return _logLevel;\n  }\n\n  /**\n   * @summary Set log level of the logger.\n   *\n   * @desc Set the log level of the logger by assign this property one of the following values:\n   *\n   * ```javascript\n   * [ 'MUTE', 'VERBOSE', 'DEBUG', 'ERROR', 'WARN', 'LOG', 'INFO' ]\n   * ```\n   *\n   * `MUTE` will disable outputs, while among the reset of the levels, when one is set, all of the right ones will also be flagged as `true`.\n   *\n   * For example, `logger.logLevel = 'DEBUG';` will enable APIs `debug`, `error`, ..., till `info`, but disable `verbose`.\n   *\n   * Note that only string assignment will be handled.\n   *\n   * @type {String}\n   * @param {String} lvl Log level.\n   */\n  set logLevel( lvl ) {\n\n    // only handle string level\n    if ( typeof lvl !== 'string' ) {\n      return;\n    }\n\n    lvl = lvl.toUpperCase( );\n\n    _logLevel = genLogLevel( logLvl => logLvl === lvl );\n\n  }\n\n  /**\n   * @summary Get the time format string of the logger.\n   *\n   * @desc The time format is used to feed `moment.format()`.\n   *\n   * The default value is `'HH.mm.ss.SSS'`.\n   *\n   * @type {String}\n   */\n  get timeFormat( ) {\n    return _timeFormat;\n  }\n\n  /**\n   * @summary Set the time format string of the logger.\n   *\n   * @desc The time format is used to feed `moment.format()`.\n   *\n   * Note that only string assignment will be handled.\n   *\n   * @type {String}\n   * @param {String} fmt The time format is used to feed `moment.format()`.\n   */\n  set timeFormat( fmt ) {\n\n    // only handle string format\n    if ( typeof fmt !== 'string' ) {\n      return;\n    }\n\n    _timeFormat = fmt;\n  }\n\n  /**\n   * @summary Wrapper the given content with the highlight colour.\n   * @param  {String} content Content to be wrapped.\n   * @return {String}         Content wrapped using the highlight colour.\n   */\n  highlight( content ) {\n    return C.get( 'highlight' )( content );\n  }\n\n  /**\n   * @summary Inspect the given object.\n   *\n   * @desc Enforced `util.inspect` to inspect object.\n   *\n   * It may only be helpful when debugging, hence `DEBUG` level should be enabled to use this API.\n   * The `depth` of `util.inspect` is set to `7`, which should be enough for 80% of the cases.\n   *\n   * @param  {Object} object The object to be inspected.\n   */\n  inspect( object ) {\n\n    this.debug( `\\n${ inspect( object, {\n      depth: 7,\n      colors: IS_COLOURED && true\n    } ) }\\n` );\n\n  }\n\n  /**\n   * Wrapper of `console.info`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.info` API, will wrap the first argument (the message).\n   */\n  info( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'info' )( 'INFO' ) }] ${ C.get( 'info' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'INFO' ) && Reflect.apply( console.info, this, args );\n  }\n\n  /**\n   * Wrapper of `console.log`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.log` API, will wrap the first argument (the message).\n   */\n  log( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'debug' )( 'LOG' ) }] ${ C.get( 'debug' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'LOG' ) && Reflect.apply( console.log, this, args );\n  }\n\n  /**\n   * Wrapper of `console.warn`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.warn` API, will wrap the first argument (the message).\n   */\n  warn( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'warn' )( 'WARN' ) }] ${ C.get( 'warn' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'WARN' ) && Reflect.apply( console.warn, this, args );\n  }\n\n  /**\n   * Wrapper of `console.error`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.error` API, will wrap the first argument (the message).\n   */\n  error( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'error' )( 'ERROR' ) }] ${ C.get( 'error' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'ERROR' ) && Reflect.apply( console.error, this, args );\n  }\n\n  /**\n   * Wrapper of `console.log`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.log` API, will wrap the first argument (the message).\n   */\n  debug( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'debug' )( 'DEBUG' ) }] ${ C.get( 'debug' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'DEBUG' ) && Reflect.apply( console.log, this, args );\n  }\n\n  /**\n   * Wrapper of `console.log`.\n   * Extra content such as log level and time will be injected, and the message will be coloured whenever possible.\n   *\n   * Detected by `supports-color`.\n   *\n   * @param  {...String|Object} args Used to feed `console.log` API, will wrap the first argument (the message).\n   */\n  verbose( ...args ) {\n\n    // override the message\n    args[ 0 ] = `[${ C.get( 'time' )( moment().format( this.timeFormat ) ) }][${ C.get( 'debug' )( 'VERBOSE' ) }] ${ C.get( 'debug' )( args[ 0 ] ) }`;\n\n    this.logLevel.get( 'VERBOSE' ) && Reflect.apply( console.log, this, args );\n  }\n}\n\nexport const logger = new Logger( );\n"],"sourceRoot":"/source/"}